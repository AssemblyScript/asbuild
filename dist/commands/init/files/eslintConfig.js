"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.EslintConfigFile = exports.eslintConfig = void 0;
var interfaces_1 = require("../interfaces");
// We could have store it as a obj, just like package.json
// but that we strip all of the comments.
exports.eslintConfig = "module.exports = {\n    root: true,\n    parser: \"@typescript-eslint/parser\",\n    plugins: [\n      \"@typescript-eslint\",\n    ],\n    extends: [\n      \"eslint:recommended\",\n      \"plugin:@typescript-eslint/eslint-recommended\",\n      \"plugin:@typescript-eslint/recommended\",\n    ],\n    parserOptions: {\n      ecmaVersion: 2020,\n      sourceType: \"module\",\n      ecmaFeatures: {}\n    },\n  \n    // === General rules =========================================================\n  \n    rules: {\n      // Omitted semicolons are hugely popular, yet within the compiler it makes\n      // sense to be better safe than sorry.\n      \"semi\": \"error\",\n  \n      // Our code bases uses 2 spaces for indentation, and we enforce it here so\n      // files don't mix spaces, tabs or different indentation levels.\n      \"indent\": [\"error\", 2, {\n        \"SwitchCase\": 1,\n        \"VariableDeclarator\": \"first\",\n        \"offsetTernaryExpressions\": true,\n        \"ignoredNodes\": [ // FIXME: something's odd here\n          \"ConditionalExpression > *\",\n          \"ConditionalExpression > * > *\",\n          \"ConditionalExpression > * > * > *\"\n        ]\n      }],\n  \n      // This is mostly visual style, making comments look uniform.\n      \"spaced-comment\": [\"error\", \"always\", {\n        \"markers\": [\"/\"],   // triple-slash\n        \"exceptions\": [\"/\"] // all slashes\n      }],\n  \n      // This tends to be annoying as it encourages developers to make everything\n      // that is never reassigned a 'const', sometimes semantically incorrect so,\n      // typically leading to huge diffs in follow-up PRs modifying affected code.\n      \"prefer-const\": \"off\",\n  \n      // It is perfectly fine to declare top-level variables with `var`, yet this\n      // rule doesn't provide configuration options that would help.\n      \"no-var\": \"off\",\n  \n      // Quite often, dealing with multiple related cases at once or otherwise\n      // falling through is exactly the point of using a switch.\n      \"no-fallthrough\": \"off\",\n  \n      // Typical false-positives here are `do { ... } while (true)` statements or\n      // similar, but the only option provided here is not checking any loops.\n      \"no-constant-condition\": [\"error\", { checkLoops: false }],\n  \n      // Functions are nested in blocks occasionally, and there haven't been any\n      // problems with this so far, so turning the check off.\n      \"no-inner-declarations\": \"off\",\n  \n      // Quite common in scenarios where an iteration starts at `current = this`.\n      \"@typescript-eslint/no-this-alias\": \"off\",\n  \n      // Disabled here, but enabled again for JavaScript files.\n      \"no-unused-vars\": \"off\",\n  \n      // Disabled here, but enabled again for TypeScript files.\n      \"@typescript-eslint/no-unused-vars\": \"off\",\n  \n      // Allow emptry functions for some of our base classes\n      \"@typescript-eslint/no-empty-function\": \"off\"\n    },\n    overrides: [\n  \n      // === TypeScript rules ====================================================\n  \n      {\n        files: [\n          \"**/assembly/**/*.ts\"\n        ],\n        rules: {\n          // Enforcing to remove function parameters on stubs makes code less\n          // maintainable, so we instead allow unused function parameters.\n          \"@typescript-eslint/no-unused-vars\": [\n            \"warn\", {\n              \"vars\": \"local\",\n              \"varsIgnorePattern\": \"^_|^[A-Z](?:From|To)?$\", // ignore type params\n              \"args\": \"none\",\n              \"ignoreRestSiblings\": false\n            }\n          ],\n  \n          // Namespaces are quite useful in AssemblyScript\n          \"@typescript-eslint/no-namespace\": \"off\",\n  \n          // There is actually codegen difference here\n          \"@typescript-eslint/no-array-constructor\": \"off\",\n  \n          // Sometimes it can't be avoided to add a @ts-ignore\n          \"@typescript-eslint/ban-ts-comment\": \"off\",\n  \n          // Utilized to achieve portability in some cases\n          \"@typescript-eslint/no-non-null-assertion\": \"off\",\n        }\n      },\n  \n      // === Compiler rules (extends AssemblyScript rules) =======================\n  \n      {\n        files: [\n          \"**/assembly/**/*.ts\"\n        ],\n        rules: {\n          // There is an actual codegen difference here - TODO: revisit\n          \"no-cond-assign\": \"off\",\n  \n          // Not all types can be omitted in AS yet - TODO: revisit\n          \"@typescript-eslint/no-inferrable-types\": \"off\",\n  \n          // Used rarely to reference internals that are not user-visible\n          \"@typescript-eslint/triple-slash-reference\": \"off\",\n  \n          // The compiler has its own `Function` class for example\n          \"no-shadow-restricted-names\": \"off\",\n          \"@typescript-eslint/ban-types\": \"off\"\n        }\n      },\n  \n      // === Standard Library rules (extends AssemblyScript rules) ===============\n  \n      {\n        files: [\n          \"**/assembly/**/*.ts\"\n        ],\n        rules: {\n          // We are implementing with --noLib, so we shadow all the time\n          \"no-shadow-restricted-names\": \"off\",\n  \n          // Similarly, sometimes we need the return type to be String, not string\n          \"@typescript-eslint/ban-types\": \"off\"\n        }\n      },\n  \n      // === Standard Definition rules (extends TypeScript rules) ================\n  \n      {\n        files: [\n          \"**/assembly/**/*.d.ts\"\n        ],\n        rules: {\n          // Often required to achieve compatibility with TypeScript\n          \"@typescript-eslint/no-explicit-any\": \"off\",\n  \n          // Interfaces can be stubs here, i.e. not yet fully implemented\n          \"@typescript-eslint/no-empty-interface\": \"off\",\n  \n          // Definitions make use of `object` to model rather unusual constraints\n          \"@typescript-eslint/ban-types\": \"off\"\n        }\n      },\n  \n      \n  \n      // === Test rules (extends TypeScript rules) ===============================\n  \n      {\n        files: [\n          \"**/assembly/__tests__/**/*.ts\"\n        ],\n        rules: {\n          // Tests typically include unusual code patterns on purpose. This is\n          // very likely not an extensive list, but covers what's there so far.\n          \"no-empty\": \"off\",\n          \"no-cond-assign\": \"off\",\n          \"no-compare-neg-zero\": \"off\",\n          \"no-inner-declarations\": \"off\",\n          \"no-constant-condition\": \"off\",\n          \"use-isnan\": \"off\",\n          \"@typescript-eslint/no-namespace\": \"off\",\n          \"@typescript-eslint/no-unused-vars\": \"off\",\n          \"@typescript-eslint/no-empty-function\": \"off\",\n          \"@typescript-eslint/no-non-null-assertion\": \"off\",\n          \"@typescript-eslint/no-extra-semi\": \"off\",\n          \"@typescript-eslint/no-inferrable-types\": \"off\",\n          \"@typescript-eslint/ban-types\": \"off\",\n          \"@typescript-eslint/triple-slash-reference\": \"off\",\n          \"@typescript-eslint/ban-ts-comment\": \"off\",\n          \"@typescript-eslint/no-extra-non-null-assertion\": \"off\",\n          \"@typescript-eslint/no-empty-interface\": \"off\"\n        }\n      },\n    ]\n  };\n";
var EslintConfigFile = /** @class */ (function (_super) {
    __extends(EslintConfigFile, _super);
    function EslintConfigFile() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.path = ".eslintrc.js";
        _this.description = "AssemblyScript friendly eslint configuration file";
        _this.updateOldContent = null;
        return _this;
    }
    EslintConfigFile.prototype.getContent = function () {
        return exports.eslintConfig;
    };
    return EslintConfigFile;
}(interfaces_1.InitFile));
exports.EslintConfigFile = EslintConfigFile;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXNsaW50Q29uZmlnLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvbW1hbmRzL2luaXQvZmlsZXMvZXNsaW50Q29uZmlnLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw0Q0FBeUM7QUFFekMsMERBQTBEO0FBQzFELHlDQUF5QztBQUM1QixRQUFBLFlBQVksR0FBRyx1dk9BcU0zQixDQUFDO0FBRUY7SUFBc0Msb0NBQVE7SUFBOUM7UUFBQSxxRUFPQztRQU5DLFVBQUksR0FBRyxjQUFjLENBQUM7UUFDdEIsaUJBQVcsR0FBRyxtREFBbUQsQ0FBQztRQUNsRSxzQkFBZ0IsR0FBRyxJQUFJLENBQUM7O0lBSTFCLENBQUM7SUFIQyxxQ0FBVSxHQUFWO1FBQ0UsT0FBTyxvQkFBWSxDQUFDO0lBQ3RCLENBQUM7SUFDSCx1QkFBQztBQUFELENBQUMsQUFQRCxDQUFzQyxxQkFBUSxHQU83QztBQVBZLDRDQUFnQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluaXRGaWxlIH0gZnJvbSBcIi4uL2ludGVyZmFjZXNcIjtcblxuLy8gV2UgY291bGQgaGF2ZSBzdG9yZSBpdCBhcyBhIG9iaiwganVzdCBsaWtlIHBhY2thZ2UuanNvblxuLy8gYnV0IHRoYXQgd2Ugc3RyaXAgYWxsIG9mIHRoZSBjb21tZW50cy5cbmV4cG9ydCBjb25zdCBlc2xpbnRDb25maWcgPSBgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcm9vdDogdHJ1ZSxcbiAgICBwYXJzZXI6IFwiQHR5cGVzY3JpcHQtZXNsaW50L3BhcnNlclwiLFxuICAgIHBsdWdpbnM6IFtcbiAgICAgIFwiQHR5cGVzY3JpcHQtZXNsaW50XCIsXG4gICAgXSxcbiAgICBleHRlbmRzOiBbXG4gICAgICBcImVzbGludDpyZWNvbW1lbmRlZFwiLFxuICAgICAgXCJwbHVnaW46QHR5cGVzY3JpcHQtZXNsaW50L2VzbGludC1yZWNvbW1lbmRlZFwiLFxuICAgICAgXCJwbHVnaW46QHR5cGVzY3JpcHQtZXNsaW50L3JlY29tbWVuZGVkXCIsXG4gICAgXSxcbiAgICBwYXJzZXJPcHRpb25zOiB7XG4gICAgICBlY21hVmVyc2lvbjogMjAyMCxcbiAgICAgIHNvdXJjZVR5cGU6IFwibW9kdWxlXCIsXG4gICAgICBlY21hRmVhdHVyZXM6IHt9XG4gICAgfSxcbiAgXG4gICAgLy8gPT09IEdlbmVyYWwgcnVsZXMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIFxuICAgIHJ1bGVzOiB7XG4gICAgICAvLyBPbWl0dGVkIHNlbWljb2xvbnMgYXJlIGh1Z2VseSBwb3B1bGFyLCB5ZXQgd2l0aGluIHRoZSBjb21waWxlciBpdCBtYWtlc1xuICAgICAgLy8gc2Vuc2UgdG8gYmUgYmV0dGVyIHNhZmUgdGhhbiBzb3JyeS5cbiAgICAgIFwic2VtaVwiOiBcImVycm9yXCIsXG4gIFxuICAgICAgLy8gT3VyIGNvZGUgYmFzZXMgdXNlcyAyIHNwYWNlcyBmb3IgaW5kZW50YXRpb24sIGFuZCB3ZSBlbmZvcmNlIGl0IGhlcmUgc29cbiAgICAgIC8vIGZpbGVzIGRvbid0IG1peCBzcGFjZXMsIHRhYnMgb3IgZGlmZmVyZW50IGluZGVudGF0aW9uIGxldmVscy5cbiAgICAgIFwiaW5kZW50XCI6IFtcImVycm9yXCIsIDIsIHtcbiAgICAgICAgXCJTd2l0Y2hDYXNlXCI6IDEsXG4gICAgICAgIFwiVmFyaWFibGVEZWNsYXJhdG9yXCI6IFwiZmlyc3RcIixcbiAgICAgICAgXCJvZmZzZXRUZXJuYXJ5RXhwcmVzc2lvbnNcIjogdHJ1ZSxcbiAgICAgICAgXCJpZ25vcmVkTm9kZXNcIjogWyAvLyBGSVhNRTogc29tZXRoaW5nJ3Mgb2RkIGhlcmVcbiAgICAgICAgICBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvbiA+ICpcIixcbiAgICAgICAgICBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvbiA+ICogPiAqXCIsXG4gICAgICAgICAgXCJDb25kaXRpb25hbEV4cHJlc3Npb24gPiAqID4gKiA+ICpcIlxuICAgICAgICBdXG4gICAgICB9XSxcbiAgXG4gICAgICAvLyBUaGlzIGlzIG1vc3RseSB2aXN1YWwgc3R5bGUsIG1ha2luZyBjb21tZW50cyBsb29rIHVuaWZvcm0uXG4gICAgICBcInNwYWNlZC1jb21tZW50XCI6IFtcImVycm9yXCIsIFwiYWx3YXlzXCIsIHtcbiAgICAgICAgXCJtYXJrZXJzXCI6IFtcIi9cIl0sICAgLy8gdHJpcGxlLXNsYXNoXG4gICAgICAgIFwiZXhjZXB0aW9uc1wiOiBbXCIvXCJdIC8vIGFsbCBzbGFzaGVzXG4gICAgICB9XSxcbiAgXG4gICAgICAvLyBUaGlzIHRlbmRzIHRvIGJlIGFubm95aW5nIGFzIGl0IGVuY291cmFnZXMgZGV2ZWxvcGVycyB0byBtYWtlIGV2ZXJ5dGhpbmdcbiAgICAgIC8vIHRoYXQgaXMgbmV2ZXIgcmVhc3NpZ25lZCBhICdjb25zdCcsIHNvbWV0aW1lcyBzZW1hbnRpY2FsbHkgaW5jb3JyZWN0IHNvLFxuICAgICAgLy8gdHlwaWNhbGx5IGxlYWRpbmcgdG8gaHVnZSBkaWZmcyBpbiBmb2xsb3ctdXAgUFJzIG1vZGlmeWluZyBhZmZlY3RlZCBjb2RlLlxuICAgICAgXCJwcmVmZXItY29uc3RcIjogXCJvZmZcIixcbiAgXG4gICAgICAvLyBJdCBpcyBwZXJmZWN0bHkgZmluZSB0byBkZWNsYXJlIHRvcC1sZXZlbCB2YXJpYWJsZXMgd2l0aCBcXGB2YXJcXGAsIHlldCB0aGlzXG4gICAgICAvLyBydWxlIGRvZXNuJ3QgcHJvdmlkZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdGhhdCB3b3VsZCBoZWxwLlxuICAgICAgXCJuby12YXJcIjogXCJvZmZcIixcbiAgXG4gICAgICAvLyBRdWl0ZSBvZnRlbiwgZGVhbGluZyB3aXRoIG11bHRpcGxlIHJlbGF0ZWQgY2FzZXMgYXQgb25jZSBvciBvdGhlcndpc2VcbiAgICAgIC8vIGZhbGxpbmcgdGhyb3VnaCBpcyBleGFjdGx5IHRoZSBwb2ludCBvZiB1c2luZyBhIHN3aXRjaC5cbiAgICAgIFwibm8tZmFsbHRocm91Z2hcIjogXCJvZmZcIixcbiAgXG4gICAgICAvLyBUeXBpY2FsIGZhbHNlLXBvc2l0aXZlcyBoZXJlIGFyZSBcXGBkbyB7IC4uLiB9IHdoaWxlICh0cnVlKVxcYCBzdGF0ZW1lbnRzIG9yXG4gICAgICAvLyBzaW1pbGFyLCBidXQgdGhlIG9ubHkgb3B0aW9uIHByb3ZpZGVkIGhlcmUgaXMgbm90IGNoZWNraW5nIGFueSBsb29wcy5cbiAgICAgIFwibm8tY29uc3RhbnQtY29uZGl0aW9uXCI6IFtcImVycm9yXCIsIHsgY2hlY2tMb29wczogZmFsc2UgfV0sXG4gIFxuICAgICAgLy8gRnVuY3Rpb25zIGFyZSBuZXN0ZWQgaW4gYmxvY2tzIG9jY2FzaW9uYWxseSwgYW5kIHRoZXJlIGhhdmVuJ3QgYmVlbiBhbnlcbiAgICAgIC8vIHByb2JsZW1zIHdpdGggdGhpcyBzbyBmYXIsIHNvIHR1cm5pbmcgdGhlIGNoZWNrIG9mZi5cbiAgICAgIFwibm8taW5uZXItZGVjbGFyYXRpb25zXCI6IFwib2ZmXCIsXG4gIFxuICAgICAgLy8gUXVpdGUgY29tbW9uIGluIHNjZW5hcmlvcyB3aGVyZSBhbiBpdGVyYXRpb24gc3RhcnRzIGF0IFxcYGN1cnJlbnQgPSB0aGlzXFxgLlxuICAgICAgXCJAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1wiOiBcIm9mZlwiLFxuICBcbiAgICAgIC8vIERpc2FibGVkIGhlcmUsIGJ1dCBlbmFibGVkIGFnYWluIGZvciBKYXZhU2NyaXB0IGZpbGVzLlxuICAgICAgXCJuby11bnVzZWQtdmFyc1wiOiBcIm9mZlwiLFxuICBcbiAgICAgIC8vIERpc2FibGVkIGhlcmUsIGJ1dCBlbmFibGVkIGFnYWluIGZvciBUeXBlU2NyaXB0IGZpbGVzLlxuICAgICAgXCJAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcIjogXCJvZmZcIixcbiAgXG4gICAgICAvLyBBbGxvdyBlbXB0cnkgZnVuY3Rpb25zIGZvciBzb21lIG9mIG91ciBiYXNlIGNsYXNzZXNcbiAgICAgIFwiQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXCI6IFwib2ZmXCJcbiAgICB9LFxuICAgIG92ZXJyaWRlczogW1xuICBcbiAgICAgIC8vID09PSBUeXBlU2NyaXB0IHJ1bGVzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgXG4gICAgICB7XG4gICAgICAgIGZpbGVzOiBbXG4gICAgICAgICAgXCIqKi9hc3NlbWJseS8qKi8qLnRzXCJcbiAgICAgICAgXSxcbiAgICAgICAgcnVsZXM6IHtcbiAgICAgICAgICAvLyBFbmZvcmNpbmcgdG8gcmVtb3ZlIGZ1bmN0aW9uIHBhcmFtZXRlcnMgb24gc3R1YnMgbWFrZXMgY29kZSBsZXNzXG4gICAgICAgICAgLy8gbWFpbnRhaW5hYmxlLCBzbyB3ZSBpbnN0ZWFkIGFsbG93IHVudXNlZCBmdW5jdGlvbiBwYXJhbWV0ZXJzLlxuICAgICAgICAgIFwiQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXCI6IFtcbiAgICAgICAgICAgIFwid2FyblwiLCB7XG4gICAgICAgICAgICAgIFwidmFyc1wiOiBcImxvY2FsXCIsXG4gICAgICAgICAgICAgIFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeX3xeW0EtWl0oPzpGcm9tfFRvKT8kXCIsIC8vIGlnbm9yZSB0eXBlIHBhcmFtc1xuICAgICAgICAgICAgICBcImFyZ3NcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgIFwiaWdub3JlUmVzdFNpYmxpbmdzXCI6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSxcbiAgXG4gICAgICAgICAgLy8gTmFtZXNwYWNlcyBhcmUgcXVpdGUgdXNlZnVsIGluIEFzc2VtYmx5U2NyaXB0XG4gICAgICAgICAgXCJAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbmFtZXNwYWNlXCI6IFwib2ZmXCIsXG4gIFxuICAgICAgICAgIC8vIFRoZXJlIGlzIGFjdHVhbGx5IGNvZGVnZW4gZGlmZmVyZW5jZSBoZXJlXG4gICAgICAgICAgXCJAdHlwZXNjcmlwdC1lc2xpbnQvbm8tYXJyYXktY29uc3RydWN0b3JcIjogXCJvZmZcIixcbiAgXG4gICAgICAgICAgLy8gU29tZXRpbWVzIGl0IGNhbid0IGJlIGF2b2lkZWQgdG8gYWRkIGEgQHRzLWlnbm9yZVxuICAgICAgICAgIFwiQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XCI6IFwib2ZmXCIsXG4gIFxuICAgICAgICAgIC8vIFV0aWxpemVkIHRvIGFjaGlldmUgcG9ydGFiaWxpdHkgaW4gc29tZSBjYXNlc1xuICAgICAgICAgIFwiQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblwiOiBcIm9mZlwiLFxuICAgICAgICB9XG4gICAgICB9LFxuICBcbiAgICAgIC8vID09PSBDb21waWxlciBydWxlcyAoZXh0ZW5kcyBBc3NlbWJseVNjcmlwdCBydWxlcykgPT09PT09PT09PT09PT09PT09PT09PT1cbiAgXG4gICAgICB7XG4gICAgICAgIGZpbGVzOiBbXG4gICAgICAgICAgXCIqKi9hc3NlbWJseS8qKi8qLnRzXCJcbiAgICAgICAgXSxcbiAgICAgICAgcnVsZXM6IHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBhbiBhY3R1YWwgY29kZWdlbiBkaWZmZXJlbmNlIGhlcmUgLSBUT0RPOiByZXZpc2l0XG4gICAgICAgICAgXCJuby1jb25kLWFzc2lnblwiOiBcIm9mZlwiLFxuICBcbiAgICAgICAgICAvLyBOb3QgYWxsIHR5cGVzIGNhbiBiZSBvbWl0dGVkIGluIEFTIHlldCAtIFRPRE86IHJldmlzaXRcbiAgICAgICAgICBcIkB0eXBlc2NyaXB0LWVzbGludC9uby1pbmZlcnJhYmxlLXR5cGVzXCI6IFwib2ZmXCIsXG4gIFxuICAgICAgICAgIC8vIFVzZWQgcmFyZWx5IHRvIHJlZmVyZW5jZSBpbnRlcm5hbHMgdGhhdCBhcmUgbm90IHVzZXItdmlzaWJsZVxuICAgICAgICAgIFwiQHR5cGVzY3JpcHQtZXNsaW50L3RyaXBsZS1zbGFzaC1yZWZlcmVuY2VcIjogXCJvZmZcIixcbiAgXG4gICAgICAgICAgLy8gVGhlIGNvbXBpbGVyIGhhcyBpdHMgb3duIFxcYEZ1bmN0aW9uXFxgIGNsYXNzIGZvciBleGFtcGxlXG4gICAgICAgICAgXCJuby1zaGFkb3ctcmVzdHJpY3RlZC1uYW1lc1wiOiBcIm9mZlwiLFxuICAgICAgICAgIFwiQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1wiOiBcIm9mZlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gIFxuICAgICAgLy8gPT09IFN0YW5kYXJkIExpYnJhcnkgcnVsZXMgKGV4dGVuZHMgQXNzZW1ibHlTY3JpcHQgcnVsZXMpID09PT09PT09PT09PT09PVxuICBcbiAgICAgIHtcbiAgICAgICAgZmlsZXM6IFtcbiAgICAgICAgICBcIioqL2Fzc2VtYmx5LyoqLyoudHNcIlxuICAgICAgICBdLFxuICAgICAgICBydWxlczoge1xuICAgICAgICAgIC8vIFdlIGFyZSBpbXBsZW1lbnRpbmcgd2l0aCAtLW5vTGliLCBzbyB3ZSBzaGFkb3cgYWxsIHRoZSB0aW1lXG4gICAgICAgICAgXCJuby1zaGFkb3ctcmVzdHJpY3RlZC1uYW1lc1wiOiBcIm9mZlwiLFxuICBcbiAgICAgICAgICAvLyBTaW1pbGFybHksIHNvbWV0aW1lcyB3ZSBuZWVkIHRoZSByZXR1cm4gdHlwZSB0byBiZSBTdHJpbmcsIG5vdCBzdHJpbmdcbiAgICAgICAgICBcIkB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcIjogXCJvZmZcIlxuICAgICAgICB9XG4gICAgICB9LFxuICBcbiAgICAgIC8vID09PSBTdGFuZGFyZCBEZWZpbml0aW9uIHJ1bGVzIChleHRlbmRzIFR5cGVTY3JpcHQgcnVsZXMpID09PT09PT09PT09PT09PT1cbiAgXG4gICAgICB7XG4gICAgICAgIGZpbGVzOiBbXG4gICAgICAgICAgXCIqKi9hc3NlbWJseS8qKi8qLmQudHNcIlxuICAgICAgICBdLFxuICAgICAgICBydWxlczoge1xuICAgICAgICAgIC8vIE9mdGVuIHJlcXVpcmVkIHRvIGFjaGlldmUgY29tcGF0aWJpbGl0eSB3aXRoIFR5cGVTY3JpcHRcbiAgICAgICAgICBcIkB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcIjogXCJvZmZcIixcbiAgXG4gICAgICAgICAgLy8gSW50ZXJmYWNlcyBjYW4gYmUgc3R1YnMgaGVyZSwgaS5lLiBub3QgeWV0IGZ1bGx5IGltcGxlbWVudGVkXG4gICAgICAgICAgXCJAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktaW50ZXJmYWNlXCI6IFwib2ZmXCIsXG4gIFxuICAgICAgICAgIC8vIERlZmluaXRpb25zIG1ha2UgdXNlIG9mIFxcYG9iamVjdFxcYCB0byBtb2RlbCByYXRoZXIgdW51c3VhbCBjb25zdHJhaW50c1xuICAgICAgICAgIFwiQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1wiOiBcIm9mZlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gIFxuICAgICAgXG4gIFxuICAgICAgLy8gPT09IFRlc3QgcnVsZXMgKGV4dGVuZHMgVHlwZVNjcmlwdCBydWxlcykgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBcbiAgICAgIHtcbiAgICAgICAgZmlsZXM6IFtcbiAgICAgICAgICBcIioqL2Fzc2VtYmx5L19fdGVzdHNfXy8qKi8qLnRzXCJcbiAgICAgICAgXSxcbiAgICAgICAgcnVsZXM6IHtcbiAgICAgICAgICAvLyBUZXN0cyB0eXBpY2FsbHkgaW5jbHVkZSB1bnVzdWFsIGNvZGUgcGF0dGVybnMgb24gcHVycG9zZS4gVGhpcyBpc1xuICAgICAgICAgIC8vIHZlcnkgbGlrZWx5IG5vdCBhbiBleHRlbnNpdmUgbGlzdCwgYnV0IGNvdmVycyB3aGF0J3MgdGhlcmUgc28gZmFyLlxuICAgICAgICAgIFwibm8tZW1wdHlcIjogXCJvZmZcIixcbiAgICAgICAgICBcIm5vLWNvbmQtYXNzaWduXCI6IFwib2ZmXCIsXG4gICAgICAgICAgXCJuby1jb21wYXJlLW5lZy16ZXJvXCI6IFwib2ZmXCIsXG4gICAgICAgICAgXCJuby1pbm5lci1kZWNsYXJhdGlvbnNcIjogXCJvZmZcIixcbiAgICAgICAgICBcIm5vLWNvbnN0YW50LWNvbmRpdGlvblwiOiBcIm9mZlwiLFxuICAgICAgICAgIFwidXNlLWlzbmFuXCI6IFwib2ZmXCIsXG4gICAgICAgICAgXCJAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbmFtZXNwYWNlXCI6IFwib2ZmXCIsXG4gICAgICAgICAgXCJAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcIjogXCJvZmZcIixcbiAgICAgICAgICBcIkB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblwiOiBcIm9mZlwiLFxuICAgICAgICAgIFwiQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblwiOiBcIm9mZlwiLFxuICAgICAgICAgIFwiQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcIjogXCJvZmZcIixcbiAgICAgICAgICBcIkB0eXBlc2NyaXB0LWVzbGludC9uby1pbmZlcnJhYmxlLXR5cGVzXCI6IFwib2ZmXCIsXG4gICAgICAgICAgXCJAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXCI6IFwib2ZmXCIsXG4gICAgICAgICAgXCJAdHlwZXNjcmlwdC1lc2xpbnQvdHJpcGxlLXNsYXNoLXJlZmVyZW5jZVwiOiBcIm9mZlwiLFxuICAgICAgICAgIFwiQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XCI6IFwib2ZmXCIsXG4gICAgICAgICAgXCJAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtbm9uLW51bGwtYXNzZXJ0aW9uXCI6IFwib2ZmXCIsXG4gICAgICAgICAgXCJAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktaW50ZXJmYWNlXCI6IFwib2ZmXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICBdXG4gIH07XG5gO1xuXG5leHBvcnQgY2xhc3MgRXNsaW50Q29uZmlnRmlsZSBleHRlbmRzIEluaXRGaWxlIHtcbiAgcGF0aCA9IFwiLmVzbGludHJjLmpzXCI7XG4gIGRlc2NyaXB0aW9uID0gXCJBc3NlbWJseVNjcmlwdCBmcmllbmRseSBlc2xpbnQgY29uZmlndXJhdGlvbiBmaWxlXCI7XG4gIHVwZGF0ZU9sZENvbnRlbnQgPSBudWxsO1xuICBnZXRDb250ZW50KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGVzbGludENvbmZpZztcbiAgfVxufVxuIl19