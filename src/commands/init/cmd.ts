import * as yargs from "yargs";
import { initFiles } from "./files";
import { askYesNo, log } from "../../utils";
import { InitResult } from "./interfaces";
import * as path from "path";
import chalk from "chalk";
import { getPmCommands } from "./files/packageJson";

const doneMsg = chalk`
Don't forget to install dependencies before you start:

  ${getPmCommands().install}

To edit the entry file, open {cyan 'assembly/index.ts'} in your editor of choice.
Create as many additional files as necessary and use them as imports.

To build the entry file to WebAssembly when you are ready, run:

  ${getPmCommands().run} build

Running the command above creates the following binaries incl. their respective
text format representations and source maps:

  {cyan ./build/untouched.wasm}
  {cyan ./build/untouched.wasm.map}
  {cyan ./build/untouched.wat}

  ^ The untouched WebAssembly module as generated by the compiler.
    This one matches your sources exactly, without any optimizations.

  {cyan ./build/optimized.wasm}
  {cyan ./build/optimized.wasm.map}
  {cyan ./build/optimized.wat}

  ^ The optimized WebAssembly module using default optimization settings.
    You can change the optimization settings in {cyan 'package.json'}.

To run the tests, do:

  ${getPmCommands().test}

The AssemblyScript documentation covers all the details:

  https://docs.assemblyscript.org

Have a nice day!
`;

function initMsg(baseDir: string): string {
  let msg = [
    chalk`This command will make sure that the following files exist in the project`,
    chalk`directory {bold "${baseDir}":}`,
    ``,
  ];
  for (let file of initFiles) {
    msg.push(chalk`  {cyan ./${file.path}}`);
    msg.push(chalk`  ${file.description}`);
    msg.push(``);
  }
  msg.push(
    `The command will try to update existing files to match the correct settings`
  );
  msg.push(``);
  return msg.join("\n");
}

export const initCmdBuilder = (y: yargs.Argv) =>
  y
    .positional("baseDir", {
      type: "string",
      default: ".",
      description: "Create a sample AS project in this directory",
    })
    .option("yes", {
      boolean: true,
      default: false,
      description: "Skip the interactive prompt",
    });

export const InitCmd: yargs.CommandModule = {
  command: "init [baseDir]",
  describe: "Create a new AS package in an given directory",
  builder: (y) =>
    initCmdBuilder(y).onFinishCommand((code: number) => process.exit(code)),
  handler: async (args): Promise<number> => {
    let retCode = 0;
    const baseDir: string = path.resolve(args.baseDir as string);
    // print initMsg
    log(initMsg(baseDir));
    // ask confirmation, return if 'No'
    if (!args.yes && !(await askYesNo(chalk`{bold Do you to continue?}`)))
      return 2;

    try {
      writeFiles(baseDir);
      log(doneMsg);
    } catch (err) {
      // https://github.com/yargs/yargs/issues/1069#issuecomment-468451450
      // If error is thrown in async handler, parser is run twice which
      // cause the help commands to print along with error stack
      // So to prevent that we catch the error and simply print it.
      log(
        chalk`{bold.bgRedBright ERROR:} Unexpected Error while trying to write init files.`,
        true
      );
      log(err, true);
      retCode = 1;
    }
    return retCode;
  },
};

export function writeFiles(baseDir: string) {
  log(``);
  for (let file of initFiles) {
    log(chalk`- Making sure that '${file.path}' is set up...`);
    const relativePath = file.getRelativePath(baseDir);
    switch (file.write(baseDir)) {
      case InitResult.CREATED:
        log(chalk`  {green Created:} ${relativePath}\n`);
        break;
      case InitResult.EXISTS:
        log(chalk`  {yellow Exists:} ${relativePath}\n`);
        break;
      case InitResult.UPDATED:
        log(chalk`  {greenBright Updated:} ${relativePath}\n`);
        break;
      default:
        break;
    }
  }
  log(chalk`{bold.green Done!}`);
}
